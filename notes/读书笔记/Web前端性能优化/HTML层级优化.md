#### 3.1 化繁为简

##### 3.1.1 减少HTML的层级嵌套

对于浏览器而言，一个网页实际上是一串非常长的字符串，并不在意你写的是否优雅。如下：

```
<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"></head><body>Hello</body></html>
```

浏览器在解析HTML、创建DOM树的过程中，基本会循环下面三个步骤：

（1）遇到字符 < 时，状态更改为“标记打开状态”；

（2）当接收一个 a~Z 字符时，会创建“起始标记”，状态更改为“标记名称状态”，并保持状态到接收 > 字符时。此期间的字符串会形成一个新的标记名称。接收到 > 字符后，将当前的新标记发送给树构造器，状态改回“数据状态”；

（3）当接收到下一个输入字符 / 时，会创建关闭标记、打开状态，并更改为“标记名称状态”。当接收到 > 字符时，会将当前的新标记发送给树构造器，并改回“数据状态”。

浏览器在创建解析器的同时，也会创建document对象。在树构建阶段，以document为根结点的DOM会不断进行修改，添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。

每个标记都有对应的DOM元素，这些元素会在接收标记时创建。我们的标签多一层时，整个对象就会多一层，同时也会多出很多属性和值。

也就是说，浏览器在解析HTML文件并构建DOM树的过程中，会将我们的标签向DOM树挂载，层级越深，DOM树就越深。实际访问的时候，需要进行遍历。DOM层级越深，遍历循环的时间复杂度越大。

##### 3.1.2 减少空标签、无用标签的滥用

有时，结合空标签实现某个图形时，如平行四边形，优先考虑使用伪类实现。

#### 3.2 标签属性及模版

##### 3.2.1 标签的style属性

尽量不要在标签上写style，将style和html结构分离。

##### 3.2.2 标签的自定义属性

较多的自定义属性或元素随意增加自定义属性会对页面性能产生一定的影响。比较推荐的一个做法是，将一个DOM块，比如一个组件单元的顶层，设置为自定义属性，因为一般情形下一个后台的请求会对应页面一块区域的显示。这样一块区域可以作为一个单元，整个页面自定义的属性总数就不会很多了。

##### 3.2.3 合理利用模版引擎

直接将数据插入页面，会造成页面频繁地重排、重绘，降低性能。

模版引擎做的事就是：给它一个模版和一个数据源，它会返回一个字符串，我们只需把这个字符串以 innerHTML 等方式写入页面即可。只在页面写一串字符串是非常快的，不会造成额外的运行负担。写完字符串，浏览器的 Reflow 和 Repaint 也只有一次，而且是局部的。

常见的模版引擎：

- 百度：baiduTemplate.js
- 阿里巴巴：juicer.js
- 腾讯：artTemplate.js
- 还有：doT.js , jQuery作者开发的 tmpl.js

一般需要传入两个值，一个是目标模版的ID，一个是JSON数据存放的变量options。原理简化如下：

（1）通过符合某种特定规则的正则匹配，如 {%%}，将目标模版片段中的带有这种类型的片段匹配出来；

（2）将这些字符，替换成传入的数据，重新合成一个完整的字符串，这些字符串里有 JavaScript 代码；

（3）通过 new Function 等方式将字符串作为参数传入，并执行这段 JavaScript 代码，重新拼合成一个完整的HTML片段。

#### 3.3 容易忽略的细节

##### 3.3.1 Link标签妙用

大多数人对Link 标签的印象主要停留在外链CSS资源上。其实，Link 标签有很多属性，下面主要看下对性能有提升的:

link 通过 rel 来定义文档的关联关系：

```
<link rel="prefetch" href="common.css" as="style">
```

网站性能的提升决定于缓存，能从缓存中加载资源就不去服务端加载。**prefetch** 的原理实际上就是利用浏览器的空闲时间先下载用户指定需要的内容，然后缓存起来，用户下次加载时，实际上是从缓存中加载，此时的请求状态码是304。prefetch 最大的作用不在于当前页面，而在于后续可能访问的页面上。

**dns-prefetch** 是来处理DNS解析的，也是一种预加载。

```
<link rel="dns-prefetch" href="http://www.dorsey.com">
```

提前解析一些域名。根据用户的浏览历史或习惯，**dns-prefetch** 会在浏览器空闲时预先将这个域名解析成IP，当用户访问这些页面时会跳过DNS解析这个环节。

**preload** 是一项新的Web标准，旨在提高性能，让FE对加载的控制更加粒度化。它让开发者有自定义加载逻辑的能力，免受基于脚本的加载器带来的性能损耗。

```
<link rel="preload" href="common.css" as="style">
```

在实际工作中，你可能需要实现一个功能：在页面生命周期的某一刻执行一段可插拔的代码段，这时如何做呢？

传统做法：将代码段放入某个 js 文件，在对应的时间节点用 script 标签引入，执行完再删除。这时的引入需要发一个请求，从服务端下载这个 js 文件，这个过程会产生额外的时间消耗。若这时页面中已经有了这段代码，但不执行，是否可以呢？不行，因为浏览器对于 js 文件的机制是加载后执行。那如何做呢？

通过 preload 预先加载，这种异步预先加载的资源暂时不会被浏览器用到，也就不会执行。当你需要执行时，再通过 script 标签引入。这时引入的资源是事先存在的资源。

```
<link rel="preload" href="point.js" as="script">

document.querySelector('.btn').addEventListener('click', function () {
	let script = document.createElement('script');
	script.src = 'point.js';
	document.body.appendChild(script);
})
```

preload 实际是牺牲一部分首屏渲染时间。preload 预加载时，在页面开始之初，会多出一个请求，只不过这个请求时在浏览器空闲时完成的，而后续操作如果需要这个资源不用再次请求，相当于减少了一次请求。

##### 3.3.2 <img> 标签

图片加载完成后会造成页面重排重绘，可以给图片设置一个固定的大小或者外套一个固定大小的标签，图片的宽高设为100%。

alt 属性对于SEO有影响，可以优化搜索引擎。

##### 3.3.3 标签的 src 属性及 href 属性

href 表示超文本引用，用在 link 、 a 等元素上，表示引用和页面关联，是在当前元素和引用资源之间建立联系。src 表示某个资源的路径，用在<img> 、<script> 、<frame>上，src 是页面内容不可缺少的一部分。

这两个属性有时会产生问题，若属性值为空，一些浏览器可能把当前页面当成属性值加载，实际加载了两个页面，一个页面嵌套在另一个页面中。

开发过程中，不要滥用自带href、 src 属性的标签，有些不需要的标签可以类似于 a 标签的写法来杜绝此类问题。尽量不要弄成空的。

```
<a href="javascript:0"></a>
```

Iframe 在传统网站或门户网站中很常见，这类网站不关注SEO，对复杂的页面导航敏感度较低。iframe 对资源的引用非常便捷，可以解决不同域之间的页面嵌套问题。

但是，一个页面将另一个页面嵌套进去，对性能影响很大。由于 iframe 隔绝的特性，嵌套页面的资源可能已经在父页面存在，但还会再次请求。

假如 iframe 是动态创建的，在一些可以查询最近浏览历史的网站中，用户单击导航，实际上可能创建了一个 iframe ，并将该 iframe 置于最前，原来的 iframe  还在，但是被隐藏了。用户单击的页面越多，iframe 就越多，页面运行就越慢。当然这类问题是有对应的优化方法，但是无论如何优化，采用该方式后再要求性能好、响应快是不太现实的。
