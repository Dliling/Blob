前面几篇主要从不同的层级对性能做相应的优化，如前端“三剑客”、资源、缓存等，实际上，能做性能优化的不仅仅是这些层面，其他方面也能做很大的优化。

**1 页面渲染过程**

**1.1 从输入一个URL到页面出现的过程**

面试的时候，经常会被问到这个问题～那这个过程经历了什么呢？

这其实是一个送信与收信的过程，总结起来大致如下：

1. DNS解析，即域名 —> IP的过程

   计算机访问需要知道IP，但是让用户通过 IP 来访问是很难的，这时就有了域名，例如 www.aaa.com ，那么就需要一种机制来将域名转化成 IP，这就是输入一个URL后发生的第一步——DNS解析，将域名解析成 IP。

2. 浏览器向目标主机发出请求，即Request

   浏览器向目标主机发送请求，包含请求头(Request Headers)和请求参数(Params)。

3. HTTP/HTTPS协议

   对于网络通信来说，数据包被截取是一件很容易的事情，为保证安全，双方做好约定，签协议，规定一份只有双方能看懂的密文，既可以做请求过滤，又可以做信息加密。这就是 HTTP/HTTPS 协议，或者更广泛地说是 TCP/IP协议——浏览器一般会选择一个大于1024的本机端口向目标 IP 地址的80端口发起 TCP 连接请求。经过标准的 TCP 握手流程（一般是三次握手：告知服务端，客户端发送准备——告知客户端，服务端接收准备——告诉服务端，客户端发送确认），建立 TCP 连接。发送内容就是我们输入的域名下的根页面，如 index.html 页面。

4. Respond Message

   作为被访问方，需要先判断访问者能不能访问，访问者的 IP 是否合法，是否在黑名单上等。信息验证通过后，会按照访问者的请求发送相应的数据包。

5. 浏览器加载及渲染页面

   这个过程涉及浏览器对 HTML 结构层的解析、静态资源的加载、CSS样式层渲染、JS行为脚本的运行等。

**1.2 不做重复的加载**

从浏览器加载这个过程看，减少重复资源、重复代码等，可以提高加载速度。

减少重复加载，可以通过开发编码规范来约定。若一个代码片段后续易被复用的话，这部分代码可以单独抽取出来成为公共资源，减少重复性的加载。

**1.3 精简 Cookie**

浏览器发出请求时，会携带各项信息，其中可能包括请求格式、缓存策略内容等，而 Cookie 也在这里面。

浏览器每次发送请求都会默认带上 Cookie，是因为 HTTP/HTTPS 协议是无状态的，也就是服务器不知道用户上次做了什么，这在很大程度上阻碍了交互式 Web 应用的体验，因为服务器每一次都需要重新知道你是谁，你来干什么。有了 Cookie ，服务器就可以设置或读取 Cookie 中的信息，比如用户的登录信息，借此维护用户与浏览器会话中的状态。Cookie 可以一定程度上帮助服务器更快地判断用户是谁，来做什么。

网络带宽是一致的，如果请求头冗余，会使整体的数据包变大，延长读取和解析的时间。

精简 Cookie 的做法很简单，由于 Cookie 本质上是一串字符串，所以除了用于保持登录状态的基本信息之外，尽量不要将其他信息写进 Cookie，尽管 Cookie 用起来很方便，但还是要让这串字符串越短越好。SessionStorage 和 LocalStorage 也可以写一些缓存信息，所以可以尽量避免过重的 Cookie。

**1.4 合理利用 SessionStorage 和 LocalStorage**

SessionStorage 和 LocalStorage是前端的存储。前者是会话（浏览器窗口）层面的缓存，在会话关闭之前，这个缓存会一直都在；后者是浏览器本地缓存，存储在浏览器的本地文件夹中，即使会话关闭来，它也不会消失。

SessionStorage 和 LocalStorage 存储的值都是 key - value 键值对的形式。

除用户登录状态的基本信息外，需要缓存的信息可以考虑写入SessionStorage 和 LocalStorage中。

**2 控制交互请求**

Web 应用最核心的就是用户——数据信息服务之间的交互。前端是媒介，整个交互体验实际上是由一个个小的交互请求组成。这些请求并不是无成本、无消耗的，而是需要资源支撑的，比如网络带宽资源、服务器的线程服务资源等。

合理地控制交互请求、减少请求数，对系统的性能提升有很大的帮助。

**2.1 浏览器请求并发数限制**

对浏览器来说，只能从系统里分配一定的资源来完成它的功能，所以它的资源有限。因此，浏览器基于自身的情况考虑，对各类可能存在大量资源浪费的操作都做了限制，而同源的交互请求并发数就是其中之一。

目前，请求并发数的条目数常见的是6条。6条代表的意义是同源、同一时刻浏览器最多允许处理的请求是6条。这个请求可以是 XHR、非XHR，也可以是一个非常小的图片。只是是从服务端发出的，就可以算是一个请求（这也是为什么采用 CSS Sprite 的原因）。

**2.2 减少同后端交互请求数**

浏览器的并发限制不仅对浏览器本身有好处，对服务端也有好处。对服务端来说，某一时刻的并发量过大是一个非常重要且严肃的问题，严重时可能导致数据库宕机或服务器崩掉。

服务端并发总量要想提高，常见做法有三种：一是加服务器、做集群；二是改变架构，如新增中间件分发、服务总线；三是加快处理的速度，如数据库缓存、资源或模版等。加服务器的方法简单粗暴，但非常耗钱！改变架构对于大型应用来说成本太高。

开发工程师在开发时可以有意识地减少同后端交互的请求，如果一些请求的合并、前端的缓存、资源的打包等。下面说一些具体的小调整：

- 请求的合并：如 CSS Sprite，数据结构的调整（尽量不要采用过于简单的数据结构，需要请求多次才能完成某块前端区域的展示的数据结构）。
- 前端的缓存：SessionStorage 、 LocalStorage、Cookie 等，Cache 的合理设置也很重要，最简单的做法有缓存过期、失效时间等。
- 资源的打包：如 Gulp、Grunt、Webpack 等打包合并 JS、CSS。资源文件合并成一个，请求数自然就减少了。
- 传统的轮询方式替换成 WebSocket 推送，也可以大大降低各种空的、无效的请求，降低服务端的压力。

**2.3 代理、中间件、请求分发**

在后端与前端的中间做一个中间层作为请求分发的服务总线，也可以提升系统整体性能。服务总线其实是将接收到的请求分发到集群中的其他服务器去处理。

中间件常见的一种实现方式是用 Nginx、Node等中间层代理服务器。分发的话就存在分配不均的问题，比如一些服务器分到的请求很多，有些又很少，所以此类中间层，还具备了另一个与之相辅相成等能力——负载均衡。它能将总体的负载均衡地分发到集群上的每一台服务器上，使它们相对公平地工作。

**3 合理的数据结构**

合理的数据结构，后端易查、易存储，前端易取、易展示，可以最大限度地避免各种额外的数据结构。转化数据格式，可以缩短前端的 JS、后端线程运行的时长，提升应用的性能。

**3.1 前端展示、后端处理的思维模式**

后端语言大多是多线程的，JS 是单线程的。数据在后端处理，可以开一个线程处理，处理完再做一个返回，可以继续用其他线程来做其他事。而数据在前端处理，进程多数情况下是同步的，只能等此任务处理完成，才会继续执行其他任务。**
**

数据的结构尽量与前端展示区域的数据结构一致，这部分数据无需再做转换或合并拆分。

多加一层中间服务层后，可以在中间层做数据处理。

**3.2 数据结构宜简不宜繁
**

读取数据时，通常是通过遍历访问 key 的形式访问数据。当层级过深时，只能一层层往下访问，直到找到目标数据，这会在一定程度上影响数据读取的速度。

**3.3 采用轻量级数据交换格式**

轻量级的数据可以减少系统对数据传输和解析所做的繁琐处理，减少这部分时长，提升系统的性能。

对于前端来说，轻量级的数据交换格式，可能只有 JSON 比较常用。

**4 有趣的异步**

**4.1 异步机制**

JS 通过将程序分解成一个个的小任务，用一个异步队列注册并管理，主线程只负责分配任务即可。当主线程空闲时，异步队列里的任务会去各自开辟的小内存空间里做完事情，再将结果汇报到主线程。

若某个任务的完成需要另一个任务的结果，可以通过回调函数解决这个问题。

**4.2 Promise、async/await**

当 B 任务依赖 A 任务的结果，C 任务依赖 B 任务的结果，后续的 D 任务等，会需要一层层的 callback 回调函数，进入了“回调地狱”～这时，我们看不清函数的执行顺序，出现错误时，很难去定位问题。

Promise 和 async/await 可以使程序更加直观。Promise 先给出一个承诺，然后再做什么，从代码上可以直观地看出，如何一步步完成目的。但函数较多时，会写很多 then，抛错时也比较难分析。async/await 应运而生，比 Promise更直观，有点像同步的 try - catch。

**5 充分利用硬件 GPU 加速**

**5.1 GPU 图形处理加速**

GPU简单说就是我们常说的显卡。计算机 LCD 屏上有很多像素级大小的点，最终的图案都是由这些点组成的，这涉及巨量计算。假如将这些计算都交给 CPU，CPU 的算力负荷非常高。有了显卡后，CPU 会将图形指令分派给显卡，由专业的显卡来完成这部分计算。对于 transform 等类型的元素，浏览器实际会创建一个复合层来完成此类特效的渲染。显卡本身还可以针对图形化界面做进一步的算法优化。

之前的 CSS 章节里也提到过，CSS3 的变换属性会触发 GPU 加速，主要如下：

- translate：如 translateX、translateY、translate3d 等，主要用于图像的平移。
- rotate：同样有 x、y、z 轴的旋转，主要用于图像的旋转。
- scale：主要用于处理图像的缩放。
- opacity：用于改变图像的透明度。
- filter：滤镜。

**5.2 合理利用GPU加速**

在做各种前端动画实现时，充分利用 GPU 加速，可以使动画更为流畅，用户体验更好。

但 GPU 加速也不能滥用，要考虑硬件的情况。

通过实验可知，耗资源的程度从高到底依次为：JS 操作 DOM > 复合层渲染 > 普通 DOM 结构渲染。

如果元素的 Z 轴(z-index)较低且该元素在复合层上面渲染，那么该元素会创建复合层。假如某个 Z 轴层级很低的元素写入了 transform ，虽然这个元素被加速了，但比这个元素层级高的所有兄弟元素都会自动创建复合层，这其实不是我们想要的，而且会降低页面性能。这种情况下，可以改变这个元素的层级，设置一个合理的 z-index值。