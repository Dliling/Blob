网页的性能很多时候其实取决于资源，资源量越大，所需的下载时间就越长，性能也就越差。原因有两个：一是从资源到最终的展示过程需要解析，解析速度越慢，过程的时间也就越长；二是资源解析完毕后，还要渲染到界面，而渲染时间越长，性能就越长。本章从以下角度入手，来优化整体的性能。

1）资源解析

2）资源加载

3）资源缓存

#### 1 资源解析优化

资源解析是数据从杂乱五章的状态变为有分类、有条理的状态。

##### 1.1 DNS优化

当我们访问一个网站时，一般是输入域名，但计算机实际要将其转成IP，再来访问。转化的过程就叫DNS解析。

从域名解析成IP，这个过程很快，但也会引起延迟。浏览器通常会适当地对解析结果缓存，并对页面中出现的新域名进行解析，但不是所有的浏览器都会这么做。DNS解析之前都会先从浏览器的DNS缓存中拿数据，若缓存中没有该数据，则会继续去本地的DNS缓存中找，如果最终还是没找到，才会正式发起DNS解析。

dns-prefetch 会在浏览器空闲时对接下来可能访问对网站做域名解析。如果把解析过程中能先做的都先做了，后续的事情完成的效率就会高很多。

dns-prefetch 实际是通过 link 来设置的，显式预解析如下：

```
<link rel="dns-prefetch" href="http://www.a.com">
```

dns-prefetch 虽说可以加快页面解析速度，但不能滥用。现在的浏览器很智能，本身会自启隐式的预解析，比如页面中有一个 a 链接，这个链接的域名与当前页面并不在同一个域名上，浏览器就会在空闲时对 a 链接进行解析，页面上没有链接则可以通过显示设置达到DNS预解析对效果，提高页面性能。

##### 1.2 CDN 部署与缓存

CDN 作为内容分发网络主要作用是将资源缓存在 CDN 节点上，后续访问即可直接通过 CDN 节点将资源返回客户端，不需要重新回到源站服务器。

CDN 对不同的 HTTP 请求的缓存方式是不同的，一般情况下都是缓存 GET 请求。

一般常见的做法是将动态资源放在一个站点中，将静态资源，如功能逻辑代码，放在另一个站点中，CDN 只加速静态资源站点。

##### 1.3 HTTP 缓存

HTTP 缓存分为两种，有强缓存和协商缓存。两种缓存方式这里就不再赘述了，直接上图，详细内容大家自行搜索吧，太多了，可以参考[这里](https://github.com/Dliling/Blob/issues/29)～

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/ftIoaH9FicoaNIibaxO5mq1jVaapfH3ibJa0ECTgiciaFdzcgGlCE5lOE37Tm0jvnl06olpGQwWMtSOVc5icUYe3dqkA/640?wx_fmt=jpeg" alt="img" style="zoom:50%;" />

#### 2 加载模式

##### 2.1 懒加载

有人称之为按需加载，它只会加载我们需要的东西。它的加载模式是一开始并不把网站所有的内容都展现出来，而是先加载肉眼所及的那部分内容。比如1-2屏的内容，手指往下滑动就能看完，当把这部分内容看完后，系统会重新把接下来的1～2页内容再次加载出来，不断循环，直到把整个长页的内容加载完。
目前有很多成熟的懒加载类库，大家使用的时候选择合适的就好～懒加载读取的是全部数据，并以优化一次加载的数据量的方式来优化页面性能。

##### 2.2 分页加载

数据量特别大、图片特别多的时候，可以考虑分页加载。分页加载读取的其实是一小部分数据。

当我们请求第一页的时候，后台加载第一页的同时，可以默默查询第二页，将其放入缓存，当单击下一页的时候，会直接从缓存中读取数据，再配合AJAX使用，用户打开页面时流畅度很多。

##### 2.3 区域无刷AJAX加载

无论是 Promise、 fetch、async/await 等，还是基于这些出现的 axios 、request 等上层封装，思想基本与AJAX一致，即请求数据并做到无刷区域性渲染。它们的区别只在于代码的直观性和可维护性（如回调处理等）。

#### 3 资源优化处理

##### 3.1 CSS预处理与压缩

预处理方式编写增加的是代码的可读性和可维护性，目前 webpack可配置通过配置 loader 和plugin ，来支持CSS的解析和压缩合并～例如：

```
module.exports = {
  // ... config
  module：{
    rules: [
      {
          test: /\.css$/,
          use: [
              MiniCssExtractPlugin.loader, // 和style-loader互斥
              // 'style-loader', // 创建style标签，链式调用，从右到左
              'css-loader'
          ]
      },
    ] 
  }, 
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name]_[contenthash:8].css'
    })
  ]
}
```

**3.2 JavaScript代码压缩处理**

webpack 中内置了 UglifyJS，直接使用就可以～

```
module.exports = {  
	// ... config 
	plugins: [    
		new webpack.optimize.UglifyJSPlugin()  
	]
}
```

##### 3.3 Base64的妙用

相比Base256，Base64的图片实际更大，但是Base64的解析速度要更快～

##### 3.4 大、中、小图片方案及图片压缩

同一张图片用在不同场景下，可以根据场景进行区分，如 favicon 最小，需要几KB的小图，logo稍微大一些，可能需要十几KB，这样大大减少系统所负荷的资源，提高系统的性能。

##### 3.5 屏蔽开发时的调试、日志代码

生产环境的线上包将调试、日志等去除，可在使用 webpack 插件压缩代码时进行配置。